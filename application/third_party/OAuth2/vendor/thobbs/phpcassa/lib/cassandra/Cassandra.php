<?php
namespace cassandra;
/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


interface CassandraIf {
  public function login(\cassandra\AuthenticationRequest $auth_request);
  public function set_keyspace($keyspace);
  public function get($key, \cassandra\ColumnPath $column_path, $consistency_level);
  public function get_slice($key, \cassandra\ColumnParent $column_parent, \cassandra\SlicePredicate $predicate, $consistency_level);
  public function get_count($key, \cassandra\ColumnParent $column_parent, \cassandra\SlicePredicate $predicate, $consistency_level);
  public function multiget_slice($keys, \cassandra\ColumnParent $column_parent, \cassandra\SlicePredicate $predicate, $consistency_level);
  public function multiget_count($keys, \cassandra\ColumnParent $column_parent, \cassandra\SlicePredicate $predicate, $consistency_level);
  public function get_range_slices(\cassandra\ColumnParent $column_parent, \cassandra\SlicePredicate $predicate, \cassandra\KeyRange $range, $consistency_level);
  public function get_paged_slice($column_family, \cassandra\KeyRange $range, $start_column, $consistency_level);
  public function get_indexed_slices(\cassandra\ColumnParent $column_parent, \cassandra\IndexClause $index_clause, \cassandra\SlicePredicate $column_predicate, $consistency_level);
  public function insert($key, \cassandra\ColumnParent $column_parent, \cassandra\Column $column, $consistency_level);
  public function add($key, \cassandra\ColumnParent $column_parent, \cassandra\CounterColumn $column, $consistency_level);
  public function remove($key, \cassandra\ColumnPath $column_path, $timestamp, $consistency_level);
  public function remove_counter($key, \cassandra\ColumnPath $path, $consistency_level);
  public function batch_mutate($mutation_map, $consistency_level);
  public function atomic_batch_mutate($mutation_map, $consistency_level);
  public function truncate($cfname);
  public function describe_schema_versions();
  public function describe_keyspaces();
  public function describe_cluster_name();
  public function describe_version();
  public function describe_ring($keyspace);
  public function describe_token_map();
  public function describe_partitioner();
  public function describe_snitch();
  public function describe_keyspace($keyspace);
  public function describe_splits($cfName, $start_token, $end_token, $keys_per_split);
  public function trace_next_query();
  public function describe_splits_ex($cfName, $start_token, $end_token, $keys_per_split);
  public function system_add_column_family(\cassandra\CfDef $cf_def);
  public function system_drop_column_family($column_family);
  public function system_add_keyspace(\cassandra\KsDef $ks_def);
  public function system_drop_keyspace($keyspace);
  public function system_update_keyspace(\cassandra\KsDef $ks_def);
  public function system_update_column_family(\cassandra\CfDef $cf_def);
  public function execute_cql_query($query, $compression);
  public function execute_cql3_query($query, $compression, $consistency);
  public function prepare_cql_query($query, $compression);
  public function prepare_cql3_query($query, $compression);
  public function execute_prepared_cql_query($itemId, $values);
  public function execute_prepared_cql3_query($itemId, $values, $consistency);
  public function set_cql_version($version);
}

class CassandraClient implements \cassandra\CassandraIf {
  protected $input_ = null;
  protected $output_ = null;

  protected $seqid_ = 0;

  public function __construct($input, $output=null) {
    $this->input_ = $input;
    $this->output_ = $output ? $output : $input;
    $this->bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
  }

  public function login(\cassandra\AuthenticationRequest $auth_request)
  {
    $this->send_login($auth_request);
    $this->recv_login();
  }

  public function send_login(\cassandra\AuthenticationRequest $auth_request)
  {
    $args = new \cassandra\Cassandra_login_args();
    $args->auth_request = $auth_request;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'login', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('login', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_login()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_login_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_login_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->authnx !== null) {
      throw $result->authnx;
    }
    if ($result->authzx !== null) {
      throw $result->authzx;
    }
    return;
  }

  public function set_keyspace($keyspace)
  {
    $this->send_set_keyspace($keyspace);
    $this->recv_set_keyspace();
  }

  public function send_set_keyspace($keyspace)
  {
    $args = new \cassandra\Cassandra_set_keyspace_args();
    $args->keyspace = $keyspace;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'set_keyspace', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('set_keyspace', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_set_keyspace()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_set_keyspace_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_set_keyspace_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    return;
  }

  public function get($key, \cassandra\ColumnPath $column_path, $consistency_level)
  {
    $this->send_get($key, $column_path, $consistency_level);
    return $this->recv_get();
  }

  public function send_get($key, \cassandra\ColumnPath $column_path, $consistency_level)
  {
    $args = new \cassandra\Cassandra_get_args();
    $args->key = $key;
    $args->column_path = $column_path;
    $args->consistency_level = $consistency_level;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_get_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_get_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->nfe !== null) {
      throw $result->nfe;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new \Exception("get failed: unknown result");
  }

  public function get_slice($key, \cassandra\ColumnParent $column_parent, \cassandra\SlicePredicate $predicate, $consistency_level)
  {
    $this->send_get_slice($key, $column_parent, $predicate, $consistency_level);
    return $this->recv_get_slice();
  }

  public function send_get_slice($key, \cassandra\ColumnParent $column_parent, \cassandra\SlicePredicate $predicate, $consistency_level)
  {
    $args = new \cassandra\Cassandra_get_slice_args();
    $args->key = $key;
    $args->column_parent = $column_parent;
    $args->predicate = $predicate;
    $args->consistency_level = $consistency_level;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_slice', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_slice', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_slice()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_get_slice_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_get_slice_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new \Exception("get_slice failed: unknown result");
  }

  public function get_count($key, \cassandra\ColumnParent $column_parent, \cassandra\SlicePredicate $predicate, $consistency_level)
  {
    $this->send_get_count($key, $column_parent, $predicate, $consistency_level);
    return $this->recv_get_count();
  }

  public function send_get_count($key, \cassandra\ColumnParent $column_parent, \cassandra\SlicePredicate $predicate, $consistency_level)
  {
    $args = new \cassandra\Cassandra_get_count_args();
    $args->key = $key;
    $args->column_parent = $column_parent;
    $args->predicate = $predicate;
    $args->consistency_level = $consistency_level;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_count', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_count', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_count()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_get_count_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_get_count_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new \Exception("get_count failed: unknown result");
  }

  public function multiget_slice($keys, \cassandra\ColumnParent $column_parent, \cassandra\SlicePredicate $predicate, $consistency_level)
  {
    $this->send_multiget_slice($keys, $column_parent, $predicate, $consistency_level);
    return $this->recv_multiget_slice();
  }

  public function send_multiget_slice($keys, \cassandra\ColumnParent $column_parent, \cassandra\SlicePredicate $predicate, $consistency_level)
  {
    $args = new \cassandra\Cassandra_multiget_slice_args();
    $args->keys = $keys;
    $args->column_parent = $column_parent;
    $args->predicate = $predicate;
    $args->consistency_level = $consistency_level;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'multiget_slice', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('multiget_slice', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_multiget_slice()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_multiget_slice_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_multiget_slice_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new \Exception("multiget_slice failed: unknown result");
  }

  public function multiget_count($keys, \cassandra\ColumnParent $column_parent, \cassandra\SlicePredicate $predicate, $consistency_level)
  {
    $this->send_multiget_count($keys, $column_parent, $predicate, $consistency_level);
    return $this->recv_multiget_count();
  }

  public function send_multiget_count($keys, \cassandra\ColumnParent $column_parent, \cassandra\SlicePredicate $predicate, $consistency_level)
  {
    $args = new \cassandra\Cassandra_multiget_count_args();
    $args->keys = $keys;
    $args->column_parent = $column_parent;
    $args->predicate = $predicate;
    $args->consistency_level = $consistency_level;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'multiget_count', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('multiget_count', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_multiget_count()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_multiget_count_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_multiget_count_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new \Exception("multiget_count failed: unknown result");
  }

  public function get_range_slices(\cassandra\ColumnParent $column_parent, \cassandra\SlicePredicate $predicate, \cassandra\KeyRange $range, $consistency_level)
  {
    $this->send_get_range_slices($column_parent, $predicate, $range, $consistency_level);
    return $this->recv_get_range_slices();
  }

  public function send_get_range_slices(\cassandra\ColumnParent $column_parent, \cassandra\SlicePredicate $predicate, \cassandra\KeyRange $range, $consistency_level)
  {
    $args = new \cassandra\Cassandra_get_range_slices_args();
    $args->column_parent = $column_parent;
    $args->predicate = $predicate;
    $args->range = $range;
    $args->consistency_level = $consistency_level;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_range_slices', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_range_slices', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_range_slices()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_get_range_slices_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_get_range_slices_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new \Exception("get_range_slices failed: unknown result");
  }

  public function get_paged_slice($column_family, \cassandra\KeyRange $range, $start_column, $consistency_level)
  {
    $this->send_get_paged_slice($column_family, $range, $start_column, $consistency_level);
    return $this->recv_get_paged_slice();
  }

  public function send_get_paged_slice($column_family, \cassandra\KeyRange $range, $start_column, $consistency_level)
  {
    $args = new \cassandra\Cassandra_get_paged_slice_args();
    $args->column_family = $column_family;
    $args->range = $range;
    $args->start_column = $start_column;
    $args->consistency_level = $consistency_level;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_paged_slice', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_paged_slice', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_paged_slice()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_get_paged_slice_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_get_paged_slice_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new \Exception("get_paged_slice failed: unknown result");
  }

  public function get_indexed_slices(\cassandra\ColumnParent $column_parent, \cassandra\IndexClause $index_clause, \cassandra\SlicePredicate $column_predicate, $consistency_level)
  {
    $this->send_get_indexed_slices($column_parent, $index_clause, $column_predicate, $consistency_level);
    return $this->recv_get_indexed_slices();
  }

  public function send_get_indexed_slices(\cassandra\ColumnParent $column_parent, \cassandra\IndexClause $index_clause, \cassandra\SlicePredicate $column_predicate, $consistency_level)
  {
    $args = new \cassandra\Cassandra_get_indexed_slices_args();
    $args->column_parent = $column_parent;
    $args->index_clause = $index_clause;
    $args->column_predicate = $column_predicate;
    $args->consistency_level = $consistency_level;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_indexed_slices', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_indexed_slices', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_indexed_slices()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_get_indexed_slices_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_get_indexed_slices_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new \Exception("get_indexed_slices failed: unknown result");
  }

  public function insert($key, \cassandra\ColumnParent $column_parent, \cassandra\Column $column, $consistency_level)
  {
    $this->send_insert($key, $column_parent, $column, $consistency_level);
    $this->recv_insert();
  }

  public function send_insert($key, \cassandra\ColumnParent $column_parent, \cassandra\Column $column, $consistency_level)
  {
    $args = new \cassandra\Cassandra_insert_args();
    $args->key = $key;
    $args->column_parent = $column_parent;
    $args->column = $column;
    $args->consistency_level = $consistency_level;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'insert', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('insert', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_insert()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_insert_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_insert_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function add($key, \cassandra\ColumnParent $column_parent, \cassandra\CounterColumn $column, $consistency_level)
  {
    $this->send_add($key, $column_parent, $column, $consistency_level);
    $this->recv_add();
  }

  public function send_add($key, \cassandra\ColumnParent $column_parent, \cassandra\CounterColumn $column, $consistency_level)
  {
    $args = new \cassandra\Cassandra_add_args();
    $args->key = $key;
    $args->column_parent = $column_parent;
    $args->column = $column;
    $args->consistency_level = $consistency_level;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_add_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_add_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function remove($key, \cassandra\ColumnPath $column_path, $timestamp, $consistency_level)
  {
    $this->send_remove($key, $column_path, $timestamp, $consistency_level);
    $this->recv_remove();
  }

  public function send_remove($key, \cassandra\ColumnPath $column_path, $timestamp, $consistency_level)
  {
    $args = new \cassandra\Cassandra_remove_args();
    $args->key = $key;
    $args->column_path = $column_path;
    $args->timestamp = $timestamp;
    $args->consistency_level = $consistency_level;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'remove', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('remove', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_remove()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_remove_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_remove_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function remove_counter($key, \cassandra\ColumnPath $path, $consistency_level)
  {
    $this->send_remove_counter($key, $path, $consistency_level);
    $this->recv_remove_counter();
  }

  public function send_remove_counter($key, \cassandra\ColumnPath $path, $consistency_level)
  {
    $args = new \cassandra\Cassandra_remove_counter_args();
    $args->key = $key;
    $args->path = $path;
    $args->consistency_level = $consistency_level;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'remove_counter', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('remove_counter', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_remove_counter()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_remove_counter_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_remove_counter_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function batch_mutate($mutation_map, $consistency_level)
  {
    $this->send_batch_mutate($mutation_map, $consistency_level);
    $this->recv_batch_mutate();
  }

  public function send_batch_mutate($mutation_map, $consistency_level)
  {
    $args = new \cassandra\Cassandra_batch_mutate_args();
    $args->mutation_map = $mutation_map;
    $args->consistency_level = $consistency_level;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'batch_mutate', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('batch_mutate', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_batch_mutate()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_batch_mutate_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_batch_mutate_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function atomic_batch_mutate($mutation_map, $consistency_level)
  {
    $this->send_atomic_batch_mutate($mutation_map, $consistency_level);
    $this->recv_atomic_batch_mutate();
  }

  public function send_atomic_batch_mutate($mutation_map, $consistency_level)
  {
    $args = new \cassandra\Cassandra_atomic_batch_mutate_args();
    $args->mutation_map = $mutation_map;
    $args->consistency_level = $consistency_level;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'atomic_batch_mutate', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('atomic_batch_mutate', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_atomic_batch_mutate()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_atomic_batch_mutate_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_atomic_batch_mutate_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function truncate($cfname)
  {
    $this->send_truncate($cfname);
    $this->recv_truncate();
  }

  public function send_truncate($cfname)
  {
    $args = new \cassandra\Cassandra_truncate_args();
    $args->cfname = $cfname;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'truncate', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('truncate', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_truncate()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_truncate_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_truncate_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function describe_schema_versions()
  {
    $this->send_describe_schema_versions();
    return $this->recv_describe_schema_versions();
  }

  public function send_describe_schema_versions()
  {
    $args = new \cassandra\Cassandra_describe_schema_versions_args();
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_schema_versions', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_schema_versions', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_schema_versions()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_schema_versions_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_describe_schema_versions_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("describe_schema_versions failed: unknown result");
  }

  public function describe_keyspaces()
  {
    $this->send_describe_keyspaces();
    return $this->recv_describe_keyspaces();
  }

  public function send_describe_keyspaces()
  {
    $args = new \cassandra\Cassandra_describe_keyspaces_args();
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_keyspaces', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_keyspaces', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_keyspaces()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_keyspaces_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_describe_keyspaces_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("describe_keyspaces failed: unknown result");
  }

  public function describe_cluster_name()
  {
    $this->send_describe_cluster_name();
    return $this->recv_describe_cluster_name();
  }

  public function send_describe_cluster_name()
  {
    $args = new \cassandra\Cassandra_describe_cluster_name_args();
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_cluster_name', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_cluster_name', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_cluster_name()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_cluster_name_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_describe_cluster_name_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("describe_cluster_name failed: unknown result");
  }

  public function describe_version()
  {
    $this->send_describe_version();
    return $this->recv_describe_version();
  }

  public function send_describe_version()
  {
    $args = new \cassandra\Cassandra_describe_version_args();
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_version', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_version', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_version()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_version_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_describe_version_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("describe_version failed: unknown result");
  }

  public function describe_ring($keyspace)
  {
    $this->send_describe_ring($keyspace);
    return $this->recv_describe_ring();
  }

  public function send_describe_ring($keyspace)
  {
    $args = new \cassandra\Cassandra_describe_ring_args();
    $args->keyspace = $keyspace;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_ring', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_ring', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_ring()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_ring_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_describe_ring_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("describe_ring failed: unknown result");
  }

  public function describe_token_map()
  {
    $this->send_describe_token_map();
    return $this->recv_describe_token_map();
  }

  public function send_describe_token_map()
  {
    $args = new \cassandra\Cassandra_describe_token_map_args();
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_token_map', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_token_map', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_token_map()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_token_map_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_describe_token_map_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("describe_token_map failed: unknown result");
  }

  public function describe_partitioner()
  {
    $this->send_describe_partitioner();
    return $this->recv_describe_partitioner();
  }

  public function send_describe_partitioner()
  {
    $args = new \cassandra\Cassandra_describe_partitioner_args();
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_partitioner', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_partitioner', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_partitioner()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_partitioner_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_describe_partitioner_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("describe_partitioner failed: unknown result");
  }

  public function describe_snitch()
  {
    $this->send_describe_snitch();
    return $this->recv_describe_snitch();
  }

  public function send_describe_snitch()
  {
    $args = new \cassandra\Cassandra_describe_snitch_args();
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_snitch', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_snitch', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_snitch()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_snitch_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_describe_snitch_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("describe_snitch failed: unknown result");
  }

  public function describe_keyspace($keyspace)
  {
    $this->send_describe_keyspace($keyspace);
    return $this->recv_describe_keyspace();
  }

  public function send_describe_keyspace($keyspace)
  {
    $args = new \cassandra\Cassandra_describe_keyspace_args();
    $args->keyspace = $keyspace;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_keyspace', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_keyspace', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_keyspace()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_keyspace_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_describe_keyspace_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->nfe !== null) {
      throw $result->nfe;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("describe_keyspace failed: unknown result");
  }

  public function describe_splits($cfName, $start_token, $end_token, $keys_per_split)
  {
    $this->send_describe_splits($cfName, $start_token, $end_token, $keys_per_split);
    return $this->recv_describe_splits();
  }

  public function send_describe_splits($cfName, $start_token, $end_token, $keys_per_split)
  {
    $args = new \cassandra\Cassandra_describe_splits_args();
    $args->cfName = $cfName;
    $args->start_token = $start_token;
    $args->end_token = $end_token;
    $args->keys_per_split = $keys_per_split;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_splits', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_splits', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_splits()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_splits_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_describe_splits_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("describe_splits failed: unknown result");
  }

  public function trace_next_query()
  {
    $this->send_trace_next_query();
    return $this->recv_trace_next_query();
  }

  public function send_trace_next_query()
  {
    $args = new \cassandra\Cassandra_trace_next_query_args();
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'trace_next_query', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('trace_next_query', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_trace_next_query()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_trace_next_query_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_trace_next_query_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("trace_next_query failed: unknown result");
  }

  public function describe_splits_ex($cfName, $start_token, $end_token, $keys_per_split)
  {
    $this->send_describe_splits_ex($cfName, $start_token, $end_token, $keys_per_split);
    return $this->recv_describe_splits_ex();
  }

  public function send_describe_splits_ex($cfName, $start_token, $end_token, $keys_per_split)
  {
    $args = new \cassandra\Cassandra_describe_splits_ex_args();
    $args->cfName = $cfName;
    $args->start_token = $start_token;
    $args->end_token = $end_token;
    $args->keys_per_split = $keys_per_split;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_splits_ex', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_splits_ex', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_splits_ex()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_splits_ex_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_describe_splits_ex_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("describe_splits_ex failed: unknown result");
  }

  public function system_add_column_family(\cassandra\CfDef $cf_def)
  {
    $this->send_system_add_column_family($cf_def);
    return $this->recv_system_add_column_family();
  }

  public function send_system_add_column_family(\cassandra\CfDef $cf_def)
  {
    $args = new \cassandra\Cassandra_system_add_column_family_args();
    $args->cf_def = $cf_def;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'system_add_column_family', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('system_add_column_family', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_system_add_column_family()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_system_add_column_family_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_system_add_column_family_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("system_add_column_family failed: unknown result");
  }

  public function system_drop_column_family($column_family)
  {
    $this->send_system_drop_column_family($column_family);
    return $this->recv_system_drop_column_family();
  }

  public function send_system_drop_column_family($column_family)
  {
    $args = new \cassandra\Cassandra_system_drop_column_family_args();
    $args->column_family = $column_family;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'system_drop_column_family', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('system_drop_column_family', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_system_drop_column_family()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_system_drop_column_family_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_system_drop_column_family_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("system_drop_column_family failed: unknown result");
  }

  public function system_add_keyspace(\cassandra\KsDef $ks_def)
  {
    $this->send_system_add_keyspace($ks_def);
    return $this->recv_system_add_keyspace();
  }

  public function send_system_add_keyspace(\cassandra\KsDef $ks_def)
  {
    $args = new \cassandra\Cassandra_system_add_keyspace_args();
    $args->ks_def = $ks_def;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'system_add_keyspace', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('system_add_keyspace', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_system_add_keyspace()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_system_add_keyspace_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_system_add_keyspace_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("system_add_keyspace failed: unknown result");
  }

  public function system_drop_keyspace($keyspace)
  {
    $this->send_system_drop_keyspace($keyspace);
    return $this->recv_system_drop_keyspace();
  }

  public function send_system_drop_keyspace($keyspace)
  {
    $args = new \cassandra\Cassandra_system_drop_keyspace_args();
    $args->keyspace = $keyspace;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'system_drop_keyspace', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('system_drop_keyspace', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_system_drop_keyspace()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_system_drop_keyspace_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_system_drop_keyspace_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("system_drop_keyspace failed: unknown result");
  }

  public function system_update_keyspace(\cassandra\KsDef $ks_def)
  {
    $this->send_system_update_keyspace($ks_def);
    return $this->recv_system_update_keyspace();
  }

  public function send_system_update_keyspace(\cassandra\KsDef $ks_def)
  {
    $args = new \cassandra\Cassandra_system_update_keyspace_args();
    $args->ks_def = $ks_def;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'system_update_keyspace', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('system_update_keyspace', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_system_update_keyspace()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_system_update_keyspace_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_system_update_keyspace_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("system_update_keyspace failed: unknown result");
  }

  public function system_update_column_family(\cassandra\CfDef $cf_def)
  {
    $this->send_system_update_column_family($cf_def);
    return $this->recv_system_update_column_family();
  }

  public function send_system_update_column_family(\cassandra\CfDef $cf_def)
  {
    $args = new \cassandra\Cassandra_system_update_column_family_args();
    $args->cf_def = $cf_def;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'system_update_column_family', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('system_update_column_family', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_system_update_column_family()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_system_update_column_family_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_system_update_column_family_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("system_update_column_family failed: unknown result");
  }

  public function execute_cql_query($query, $compression)
  {
    $this->send_execute_cql_query($query, $compression);
    return $this->recv_execute_cql_query();
  }

  public function send_execute_cql_query($query, $compression)
  {
    $args = new \cassandra\Cassandra_execute_cql_query_args();
    $args->query = $query;
    $args->compression = $compression;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'execute_cql_query', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('execute_cql_query', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_execute_cql_query()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_execute_cql_query_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_execute_cql_query_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("execute_cql_query failed: unknown result");
  }

  public function execute_cql3_query($query, $compression, $consistency)
  {
    $this->send_execute_cql3_query($query, $compression, $consistency);
    return $this->recv_execute_cql3_query();
  }

  public function send_execute_cql3_query($query, $compression, $consistency)
  {
    $args = new \cassandra\Cassandra_execute_cql3_query_args();
    $args->query = $query;
    $args->compression = $compression;
    $args->consistency = $consistency;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'execute_cql3_query', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('execute_cql3_query', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_execute_cql3_query()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_execute_cql3_query_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_execute_cql3_query_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("execute_cql3_query failed: unknown result");
  }

  public function prepare_cql_query($query, $compression)
  {
    $this->send_prepare_cql_query($query, $compression);
    return $this->recv_prepare_cql_query();
  }

  public function send_prepare_cql_query($query, $compression)
  {
    $args = new \cassandra\Cassandra_prepare_cql_query_args();
    $args->query = $query;
    $args->compression = $compression;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'prepare_cql_query', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('prepare_cql_query', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_prepare_cql_query()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_prepare_cql_query_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_prepare_cql_query_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("prepare_cql_query failed: unknown result");
  }

  public function prepare_cql3_query($query, $compression)
  {
    $this->send_prepare_cql3_query($query, $compression);
    return $this->recv_prepare_cql3_query();
  }

  public function send_prepare_cql3_query($query, $compression)
  {
    $args = new \cassandra\Cassandra_prepare_cql3_query_args();
    $args->query = $query;
    $args->compression = $compression;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'prepare_cql3_query', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('prepare_cql3_query', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_prepare_cql3_query()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_prepare_cql3_query_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_prepare_cql3_query_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("prepare_cql3_query failed: unknown result");
  }

  public function execute_prepared_cql_query($itemId, $values)
  {
    $this->send_execute_prepared_cql_query($itemId, $values);
    return $this->recv_execute_prepared_cql_query();
  }

  public function send_execute_prepared_cql_query($itemId, $values)
  {
    $args = new \cassandra\Cassandra_execute_prepared_cql_query_args();
    $args->itemId = $itemId;
    $args->values = $values;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'execute_prepared_cql_query', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('execute_prepared_cql_query', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_execute_prepared_cql_query()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_execute_prepared_cql_query_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_execute_prepared_cql_query_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("execute_prepared_cql_query failed: unknown result");
  }

  public function execute_prepared_cql3_query($itemId, $values, $consistency)
  {
    $this->send_execute_prepared_cql3_query($itemId, $values, $consistency);
    return $this->recv_execute_prepared_cql3_query();
  }

  public function send_execute_prepared_cql3_query($itemId, $values, $consistency)
  {
    $args = new \cassandra\Cassandra_execute_prepared_cql3_query_args();
    $args->itemId = $itemId;
    $args->values = $values;
    $args->consistency = $consistency;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'execute_prepared_cql3_query', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('execute_prepared_cql3_query', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_execute_prepared_cql3_query()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_execute_prepared_cql3_query_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_execute_prepared_cql3_query_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("execute_prepared_cql3_query failed: unknown result");
  }

  public function set_cql_version($version)
  {
    $this->send_set_cql_version($version);
    $this->recv_set_cql_version();
  }

  public function send_set_cql_version($version)
  {
    $args = new \cassandra\Cassandra_set_cql_version_args();
    $args->version = $version;
    if ($this->bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'set_cql_version', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('set_cql_version', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_set_cql_version()
  {
    if ($this->bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_set_cql_version_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \cassandra\Cassandra_set_cql_version_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    return;
  }

}

// HELPER FUNCTIONS AND STRUCTURES

class Cassandra_login_args extends TBase {
  static $_TSPEC;

  public $auth_request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'auth_request',
          'type' => TType::STRUCT,
          'class' => '\cassandra\AuthenticationRequest',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_login_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_login_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_login_args', self::$_TSPEC, $output);
  }
}

class Cassandra_login_result extends TBase {
  static $_TSPEC;

  public $authnx = null;
  public $authzx = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'authnx',
          'type' => TType::STRUCT,
          'class' => '\cassandra\AuthenticationException',
          ),
        2 => array(
          'var' => 'authzx',
          'type' => TType::STRUCT,
          'class' => '\cassandra\AuthorizationException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_login_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_login_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_login_result', self::$_TSPEC, $output);
  }
}

class Cassandra_set_keyspace_args extends TBase {
  static $_TSPEC;

  public $keyspace = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keyspace',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_set_keyspace_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_set_keyspace_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_set_keyspace_args', self::$_TSPEC, $output);
  }
}

class Cassandra_set_keyspace_result extends TBase {
  static $_TSPEC;

  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_set_keyspace_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_set_keyspace_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_set_keyspace_result', self::$_TSPEC, $output);
  }
}

class Cassandra_get_args extends TBase {
  static $_TSPEC;

  public $key = null;
  public $column_path = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_path',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnPath',
          ),
        3 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_get_args', self::$_TSPEC, $output);
  }
}

class Cassandra_get_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $nfe = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnOrSuperColumn',
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'nfe',
          'type' => TType::STRUCT,
          'class' => '\cassandra\NotFoundException',
          ),
        3 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        4 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_get_result', self::$_TSPEC, $output);
  }
}

class Cassandra_get_slice_args extends TBase {
  static $_TSPEC;

  public $key = null;
  public $column_parent = null;
  public $predicate = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnParent',
          ),
        3 => array(
          'var' => 'predicate',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SlicePredicate',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_slice_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_slice_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_get_slice_args', self::$_TSPEC, $output);
  }
}

class Cassandra_get_slice_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\cassandra\ColumnOrSuperColumn',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_slice_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_slice_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_get_slice_result', self::$_TSPEC, $output);
  }
}

class Cassandra_get_count_args extends TBase {
  static $_TSPEC;

  public $key = null;
  public $column_parent = null;
  public $predicate = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnParent',
          ),
        3 => array(
          'var' => 'predicate',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SlicePredicate',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_count_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_count_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_get_count_args', self::$_TSPEC, $output);
  }
}

class Cassandra_get_count_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_count_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_count_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_get_count_result', self::$_TSPEC, $output);
  }
}

class Cassandra_multiget_slice_args extends TBase {
  static $_TSPEC;

  public $keys = null;
  public $column_parent = null;
  public $predicate = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keys',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnParent',
          ),
        3 => array(
          'var' => 'predicate',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SlicePredicate',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_multiget_slice_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_multiget_slice_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_multiget_slice_args', self::$_TSPEC, $output);
  }
}

class Cassandra_multiget_slice_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
              'type' => TType::STRUCT,
              'class' => '\cassandra\ColumnOrSuperColumn',
              ),
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_multiget_slice_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_multiget_slice_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_multiget_slice_result', self::$_TSPEC, $output);
  }
}

class Cassandra_multiget_count_args extends TBase {
  static $_TSPEC;

  public $keys = null;
  public $column_parent = null;
  public $predicate = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keys',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnParent',
          ),
        3 => array(
          'var' => 'predicate',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SlicePredicate',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_multiget_count_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_multiget_count_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_multiget_count_args', self::$_TSPEC, $output);
  }
}

class Cassandra_multiget_count_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_multiget_count_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_multiget_count_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_multiget_count_result', self::$_TSPEC, $output);
  }
}

class Cassandra_get_range_slices_args extends TBase {
  static $_TSPEC;

  public $column_parent = null;
  public $predicate = null;
  public $range = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnParent',
          ),
        2 => array(
          'var' => 'predicate',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SlicePredicate',
          ),
        3 => array(
          'var' => 'range',
          'type' => TType::STRUCT,
          'class' => '\cassandra\KeyRange',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_range_slices_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_range_slices_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_get_range_slices_args', self::$_TSPEC, $output);
  }
}

class Cassandra_get_range_slices_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\cassandra\KeySlice',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_range_slices_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_range_slices_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_get_range_slices_result', self::$_TSPEC, $output);
  }
}

class Cassandra_get_paged_slice_args extends TBase {
  static $_TSPEC;

  public $column_family = null;
  public $range = null;
  public $start_column = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'column_family',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'range',
          'type' => TType::STRUCT,
          'class' => '\cassandra\KeyRange',
          ),
        3 => array(
          'var' => 'start_column',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_paged_slice_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_paged_slice_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_get_paged_slice_args', self::$_TSPEC, $output);
  }
}

class Cassandra_get_paged_slice_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\cassandra\KeySlice',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_paged_slice_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_paged_slice_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_get_paged_slice_result', self::$_TSPEC, $output);
  }
}

class Cassandra_get_indexed_slices_args extends TBase {
  static $_TSPEC;

  public $column_parent = null;
  public $index_clause = null;
  public $column_predicate = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnParent',
          ),
        2 => array(
          'var' => 'index_clause',
          'type' => TType::STRUCT,
          'class' => '\cassandra\IndexClause',
          ),
        3 => array(
          'var' => 'column_predicate',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SlicePredicate',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_indexed_slices_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_indexed_slices_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_get_indexed_slices_args', self::$_TSPEC, $output);
  }
}

class Cassandra_get_indexed_slices_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\cassandra\KeySlice',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_indexed_slices_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_indexed_slices_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_get_indexed_slices_result', self::$_TSPEC, $output);
  }
}

class Cassandra_insert_args extends TBase {
  static $_TSPEC;

  public $key = null;
  public $column_parent = null;
  public $column = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnParent',
          ),
        3 => array(
          'var' => 'column',
          'type' => TType::STRUCT,
          'class' => '\cassandra\Column',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_insert_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_insert_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_insert_args', self::$_TSPEC, $output);
  }
}

class Cassandra_insert_result extends TBase {
  static $_TSPEC;

  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_insert_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_insert_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_insert_result', self::$_TSPEC, $output);
  }
}

class Cassandra_add_args extends TBase {
  static $_TSPEC;

  public $key = null;
  public $column_parent = null;
  public $column = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnParent',
          ),
        3 => array(
          'var' => 'column',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CounterColumn',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_add_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_add_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_add_args', self::$_TSPEC, $output);
  }
}

class Cassandra_add_result extends TBase {
  static $_TSPEC;

  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_add_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_add_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_add_result', self::$_TSPEC, $output);
  }
}

class Cassandra_remove_args extends TBase {
  static $_TSPEC;

  public $key = null;
  public $column_path = null;
  public $timestamp = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_path',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnPath',
          ),
        3 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_remove_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_remove_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_remove_args', self::$_TSPEC, $output);
  }
}

class Cassandra_remove_result extends TBase {
  static $_TSPEC;

  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_remove_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_remove_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_remove_result', self::$_TSPEC, $output);
  }
}

class Cassandra_remove_counter_args extends TBase {
  static $_TSPEC;

  public $key = null;
  public $path = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'path',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnPath',
          ),
        3 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_remove_counter_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_remove_counter_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_remove_counter_args', self::$_TSPEC, $output);
  }
}

class Cassandra_remove_counter_result extends TBase {
  static $_TSPEC;

  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_remove_counter_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_remove_counter_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_remove_counter_result', self::$_TSPEC, $output);
  }
}

class Cassandra_batch_mutate_args extends TBase {
  static $_TSPEC;

  public $mutation_map = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'mutation_map',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::MAP,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::MAP,
            'ktype' => TType::STRING,
            'vtype' => TType::LST,
            'key' => array(
              'type' => TType::STRING,
            ),
            'val' => array(
              'type' => TType::LST,
              'etype' => TType::STRUCT,
              'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\cassandra\Mutation',
                ),
              ),
            ),
          ),
        2 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_batch_mutate_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_batch_mutate_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_batch_mutate_args', self::$_TSPEC, $output);
  }
}

class Cassandra_batch_mutate_result extends TBase {
  static $_TSPEC;

  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_batch_mutate_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_batch_mutate_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_batch_mutate_result', self::$_TSPEC, $output);
  }
}

class Cassandra_atomic_batch_mutate_args extends TBase {
  static $_TSPEC;

  public $mutation_map = null;
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'mutation_map',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::MAP,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::MAP,
            'ktype' => TType::STRING,
            'vtype' => TType::LST,
            'key' => array(
              'type' => TType::STRING,
            ),
            'val' => array(
              'type' => TType::LST,
              'etype' => TType::STRUCT,
              'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\cassandra\Mutation',
                ),
              ),
            ),
          ),
        2 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_atomic_batch_mutate_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_atomic_batch_mutate_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_atomic_batch_mutate_args', self::$_TSPEC, $output);
  }
}

class Cassandra_atomic_batch_mutate_result extends TBase {
  static $_TSPEC;

  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_atomic_batch_mutate_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_atomic_batch_mutate_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_atomic_batch_mutate_result', self::$_TSPEC, $output);
  }
}

class Cassandra_truncate_args extends TBase {
  static $_TSPEC;

  public $cfname = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cfname',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_truncate_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_truncate_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_truncate_args', self::$_TSPEC, $output);
  }
}

class Cassandra_truncate_result extends TBase {
  static $_TSPEC;

  public $ire = null;
  public $ue = null;
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_truncate_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_truncate_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_truncate_result', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_schema_versions_args extends TBase {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_schema_versions_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_schema_versions_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_schema_versions_args', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_schema_versions_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => array(
              'type' => TType::STRING,
              ),
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_schema_versions_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_schema_versions_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_schema_versions_result', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_keyspaces_args extends TBase {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_keyspaces_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_keyspaces_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_keyspaces_args', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_keyspaces_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\cassandra\KsDef',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_keyspaces_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_keyspaces_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_keyspaces_result', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_cluster_name_args extends TBase {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_cluster_name_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_cluster_name_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_cluster_name_args', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_cluster_name_result extends TBase {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_cluster_name_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_cluster_name_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_cluster_name_result', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_version_args extends TBase {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_version_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_version_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_version_args', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_version_result extends TBase {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_version_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_version_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_version_result', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_ring_args extends TBase {
  static $_TSPEC;

  public $keyspace = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keyspace',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_ring_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_ring_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_ring_args', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_ring_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\cassandra\TokenRange',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_ring_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_ring_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_ring_result', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_token_map_args extends TBase {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_token_map_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_token_map_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_token_map_args', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_token_map_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_token_map_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_token_map_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_token_map_result', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_partitioner_args extends TBase {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_partitioner_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_partitioner_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_partitioner_args', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_partitioner_result extends TBase {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_partitioner_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_partitioner_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_partitioner_result', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_snitch_args extends TBase {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_snitch_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_snitch_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_snitch_args', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_snitch_result extends TBase {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_snitch_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_snitch_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_snitch_result', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_keyspace_args extends TBase {
  static $_TSPEC;

  public $keyspace = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keyspace',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_keyspace_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_keyspace_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_keyspace_args', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_keyspace_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $nfe = null;
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\cassandra\KsDef',
          ),
        1 => array(
          'var' => 'nfe',
          'type' => TType::STRUCT,
          'class' => '\cassandra\NotFoundException',
          ),
        2 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_keyspace_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_keyspace_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_keyspace_result', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_splits_args extends TBase {
  static $_TSPEC;

  public $cfName = null;
  public $start_token = null;
  public $end_token = null;
  public $keys_per_split = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cfName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'start_token',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'end_token',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'keys_per_split',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_splits_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_splits_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_splits_args', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_splits_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_splits_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_splits_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_splits_result', self::$_TSPEC, $output);
  }
}

class Cassandra_trace_next_query_args extends TBase {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_trace_next_query_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_trace_next_query_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_trace_next_query_args', self::$_TSPEC, $output);
  }
}

class Cassandra_trace_next_query_result extends TBase {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_trace_next_query_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_trace_next_query_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_trace_next_query_result', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_splits_ex_args extends TBase {
  static $_TSPEC;

  public $cfName = null;
  public $start_token = null;
  public $end_token = null;
  public $keys_per_split = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cfName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'start_token',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'end_token',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'keys_per_split',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_splits_ex_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_splits_ex_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_splits_ex_args', self::$_TSPEC, $output);
  }
}

class Cassandra_describe_splits_ex_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\cassandra\CfSplit',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_splits_ex_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_splits_ex_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_describe_splits_ex_result', self::$_TSPEC, $output);
  }
}

class Cassandra_system_add_column_family_args extends TBase {
  static $_TSPEC;

  public $cf_def = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cf_def',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CfDef',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_add_column_family_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_system_add_column_family_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_system_add_column_family_args', self::$_TSPEC, $output);
  }
}

class Cassandra_system_add_column_family_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_add_column_family_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_system_add_column_family_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_system_add_column_family_result', self::$_TSPEC, $output);
  }
}

class Cassandra_system_drop_column_family_args extends TBase {
  static $_TSPEC;

  public $column_family = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'column_family',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_drop_column_family_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_system_drop_column_family_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_system_drop_column_family_args', self::$_TSPEC, $output);
  }
}

class Cassandra_system_drop_column_family_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_drop_column_family_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_system_drop_column_family_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_system_drop_column_family_result', self::$_TSPEC, $output);
  }
}

class Cassandra_system_add_keyspace_args extends TBase {
  static $_TSPEC;

  public $ks_def = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ks_def',
          'type' => TType::STRUCT,
          'class' => '\cassandra\KsDef',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_add_keyspace_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_system_add_keyspace_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_system_add_keyspace_args', self::$_TSPEC, $output);
  }
}

class Cassandra_system_add_keyspace_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_add_keyspace_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_system_add_keyspace_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_system_add_keyspace_result', self::$_TSPEC, $output);
  }
}

class Cassandra_system_drop_keyspace_args extends TBase {
  static $_TSPEC;

  public $keyspace = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keyspace',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_drop_keyspace_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_system_drop_keyspace_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_system_drop_keyspace_args', self::$_TSPEC, $output);
  }
}

class Cassandra_system_drop_keyspace_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_drop_keyspace_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_system_drop_keyspace_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_system_drop_keyspace_result', self::$_TSPEC, $output);
  }
}

class Cassandra_system_update_keyspace_args extends TBase {
  static $_TSPEC;

  public $ks_def = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ks_def',
          'type' => TType::STRUCT,
          'class' => '\cassandra\KsDef',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_update_keyspace_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_system_update_keyspace_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_system_update_keyspace_args', self::$_TSPEC, $output);
  }
}

class Cassandra_system_update_keyspace_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_update_keyspace_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_system_update_keyspace_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_system_update_keyspace_result', self::$_TSPEC, $output);
  }
}

class Cassandra_system_update_column_family_args extends TBase {
  static $_TSPEC;

  public $cf_def = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cf_def',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CfDef',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_update_column_family_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_system_update_column_family_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_system_update_column_family_args', self::$_TSPEC, $output);
  }
}

class Cassandra_system_update_column_family_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_update_column_family_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_system_update_column_family_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_system_update_column_family_result', self::$_TSPEC, $output);
  }
}

class Cassandra_execute_cql_query_args extends TBase {
  static $_TSPEC;

  public $query = null;
  public $compression = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'query',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'compression',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_execute_cql_query_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_execute_cql_query_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_execute_cql_query_args', self::$_TSPEC, $output);
  }
}

class Cassandra_execute_cql_query_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $ue = null;
  public $te = null;
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CqlResult',
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        4 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_execute_cql_query_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_execute_cql_query_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_execute_cql_query_result', self::$_TSPEC, $output);
  }
}

class Cassandra_execute_cql3_query_args extends TBase {
  static $_TSPEC;

  public $query = null;
  public $compression = null;
  public $consistency = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'query',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'compression',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'consistency',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_execute_cql3_query_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_execute_cql3_query_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_execute_cql3_query_args', self::$_TSPEC, $output);
  }
}

class Cassandra_execute_cql3_query_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $ue = null;
  public $te = null;
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CqlResult',
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        4 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_execute_cql3_query_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_execute_cql3_query_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_execute_cql3_query_result', self::$_TSPEC, $output);
  }
}

class Cassandra_prepare_cql_query_args extends TBase {
  static $_TSPEC;

  public $query = null;
  public $compression = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'query',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'compression',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_prepare_cql_query_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_prepare_cql_query_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_prepare_cql_query_args', self::$_TSPEC, $output);
  }
}

class Cassandra_prepare_cql_query_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CqlPreparedResult',
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_prepare_cql_query_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_prepare_cql_query_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_prepare_cql_query_result', self::$_TSPEC, $output);
  }
}

class Cassandra_prepare_cql3_query_args extends TBase {
  static $_TSPEC;

  public $query = null;
  public $compression = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'query',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'compression',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_prepare_cql3_query_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_prepare_cql3_query_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_prepare_cql3_query_args', self::$_TSPEC, $output);
  }
}

class Cassandra_prepare_cql3_query_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CqlPreparedResult',
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_prepare_cql3_query_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_prepare_cql3_query_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_prepare_cql3_query_result', self::$_TSPEC, $output);
  }
}

class Cassandra_execute_prepared_cql_query_args extends TBase {
  static $_TSPEC;

  public $itemId = null;
  public $values = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'itemId',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_execute_prepared_cql_query_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_execute_prepared_cql_query_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_execute_prepared_cql_query_args', self::$_TSPEC, $output);
  }
}

class Cassandra_execute_prepared_cql_query_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $ue = null;
  public $te = null;
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CqlResult',
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        4 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_execute_prepared_cql_query_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_execute_prepared_cql_query_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_execute_prepared_cql_query_result', self::$_TSPEC, $output);
  }
}

class Cassandra_execute_prepared_cql3_query_args extends TBase {
  static $_TSPEC;

  public $itemId = null;
  public $values = null;
  public $consistency = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'itemId',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'consistency',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_execute_prepared_cql3_query_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_execute_prepared_cql3_query_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_execute_prepared_cql3_query_args', self::$_TSPEC, $output);
  }
}

class Cassandra_execute_prepared_cql3_query_result extends TBase {
  static $_TSPEC;

  public $success = null;
  public $ire = null;
  public $ue = null;
  public $te = null;
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CqlResult',
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        4 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_execute_prepared_cql3_query_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_execute_prepared_cql3_query_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_execute_prepared_cql3_query_result', self::$_TSPEC, $output);
  }
}

class Cassandra_set_cql_version_args extends TBase {
  static $_TSPEC;

  public $version = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'version',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_set_cql_version_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_set_cql_version_args', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_set_cql_version_args', self::$_TSPEC, $output);
  }
}

class Cassandra_set_cql_version_result extends TBase {
  static $_TSPEC;

  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_set_cql_version_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_set_cql_version_result', self::$_TSPEC, $input);
  }
  public function write($output) {
    return $this->_write('Cassandra_set_cql_version_result', self::$_TSPEC, $output);
  }
}


